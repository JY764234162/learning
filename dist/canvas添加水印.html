<!doctype html>
<html lang="zh">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>添加水印</title>
    <style>
      body {
        display: flex;
        flex-direction: column;
        align-items: center;
        margin-top: 50px;
      }
      canvas {
        border: 1px solid #ccc;
      }
    </style>
  </head>
  <body>
    <input type="file" id="upload" accept="image/*" />
    <canvas id="canvas"></canvas>
    <script>
      const uploadInput = document.getElementById("upload");
      const canvas = document.getElementById("canvas");
      const ctx = canvas.getContext("2d");

      uploadInput.addEventListener("change", (event) => {
        const file = event.target.files[0];
        if (file) {
          const img = new Image();
          img.onload = () => {
            canvas.width = img.width;
            canvas.height = img.height;
            const dominantColor = getDominantColor(img); // 获取主色调
            addWatermark(dominantColor);

            ctx.drawImage(img, 0, 0);

          };
          img.src = URL.createObjectURL(file);
        }
      });

      function addWatermark(dominantColor) {
        const date = new Date();
        const watermarkText = date.toLocaleString(); // 获取当前时间
        const textColor = getHighContrastColor(dominantColor); // 根据主色调获取高对比度水印颜色

        ctx.font = "30px Arial";
        ctx.fillStyle = textColor;
        ctx.globalAlpha = 0.3;

        const angle = (-30 * Math.PI) / 180; // 转换为弧度
        const textWidth = ctx.measureText(watermarkText).width;
        const textHeight = 30; // 设定字体高度

        const cols = Math.ceil(canvas.width / (textWidth + 50));
        const rows = Math.ceil(canvas.height / (textHeight + 50));

        ctx.save();

        for (let i = 0; i < cols; i++) {
          for (let j = 0; j < rows; j++) {
            ctx.save();
            ctx.translate(i * (textWidth + 50), j * (textHeight + 50));
            ctx.rotate(angle);
            ctx.fillText(watermarkText, 0, 0);
            ctx.restore();
          }
        }

        ctx.restore();
        ctx.globalAlpha = 1.0;
      }

      function getDominantColor(img) {
        const tempCanvas = document.createElement("canvas");
        const tempCtx = tempCanvas.getContext("2d");
        tempCanvas.width = img.width;
        tempCanvas.height = img.height;
        tempCtx.drawImage(img, 0, 0);

        const imageData = tempCtx.getImageData(0, 0, img.width, img.height);
        const data = imageData.data;
        const colorCount = {};
        let dominantColor = "";

        // 统计颜色出现次数
        for (let i = 0; i < data.length; i += 4) {
          const rgb = `${data[i]},${data[i + 1]},${data[i + 2]}`;
          colorCount[rgb] = (colorCount[rgb] || 0) + 1;
          if (!dominantColor || colorCount[rgb] > colorCount[dominantColor]) {
            dominantColor = rgb;
          }
        }

        return dominantColor; // 返回主色调
      }

      function getHighContrastColor(dominantColor) {
        const rgb = dominantColor.split(",").map(Number); // 将字符串转换为数组
        const brightness = rgb[0] * 0.299 + rgb[1] * 0.587 + rgb[2] * 0.114;

        // 根据主色调的亮度判断对比色
        // 如果亮度较高，返回黑色，否则返回白色
        return brightness > 186
          ? "rgba(0, 0, 0, 0.3)"
          : "rgba(255, 255, 255, 0.3)";
      }
    </script>
  </body>
</html>
